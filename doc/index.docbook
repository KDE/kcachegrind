<?xml version="1.0" ?>
<!DOCTYPE book PUBLIC "-//KDE//DTD DocBook XML V4.1-Based Variant V1.0//EN" "dtd/kdex.dtd" [
  <!ENTITY kcachegrind '<application>KCachegrind</application>'>
  <!ENTITY kapp "&kcachegrind;">
  <!ENTITY % addindex "IGNORE">
  <!ENTITY % English "INCLUDE">
  
  
]>

<!-- ................................................................ -->

<book lang="&language;">

<bookinfo>
<title>The KCachegrind Handbook</title>

<authorgroup>
<author>
<firstname>Josef</firstname>
<surname>Weidendorfer</surname>
<affiliation>
<address><email>Josef.Weidendorfer@gmx.de</email></address>
</affiliation>
</author>
</authorgroup>

<copyright>
<year>2002</year>
<holder>Josef Weidendorfer</holder>
</copyright>
<legalnotice>&GPLNotice;</legalnotice>

<date>22/09/2002</date>
<releaseinfo>0.2</releaseinfo>

<abstract>
<para>
&kcachegrind; is a KDE Frontend for Cachegrind, part of Valgrind.
</para>
</abstract>

<keywordset>
<keyword>KDE</keyword>
<keyword>kdesdk</keyword>
<keyword>Cachegrind</keyword>
<keyword>Valgrind</keyword>
<keyword>Profiling</keyword>
</keywordset>

</bookinfo>


<chapter id="introduction">
<title>Introduction</title>

<para>
When you develop a program, usually one of the last steps is to
make it as fast as possible (but still correct!).
You don't want to waste your time, optimizing functions rarely used.
So you need to know in which part of your program most of
the time is spent.
</para>

<para>
This is called Profiling. The program is run in control of a
profiling tool, which gives you a trace of the execution run.
After examination of the trace, you probably know where to
optimize and afterwards you verify the optimisation success again
with another profile run.
</para>

<para>
Most known is the GCC profiling tool "gprof": You need to compile
your program with option "-pg"; running the program generates a
file "gmon.out", which can be transformed into human
readable form with "gprof". The disadvantage is the needed compilation
step for a prepared executable, which has to be statically linked.
</para>

<para>
Another profiling tool is Cachegrind, part of Valgrind.
It uses the processor emulation of valgrind to run the executable,
and catches all memory accesses for the trace. The program does
not need to be recompiled;
it can use shared libraries and plugins,
and the profile measuring doesn't influence the trace results.
The trace includes the number of instruction/data memory accesses
and 1st/2nd level cache misses, and relates it to source lines
and functions of the run program
(a disadvantage is the slowdown involved the the processor emulation,
it's unfortunately around 50 times slower).
</para>

<para>
A patch for valgrind-1.0.x sources adds call tree
tracing, i.e. how the functions call each other and how many
events happen while running a function (including all called functions).
</para>

<para>
&kapp; is a visualisation tool for the profiling data
generated by Cachegrind. It is strongly advised to add support for
call tree tracing into Cachegrind, because KCachegrind is much more useful
this way.
</para>
</chapter>

<chapter id="using-kapp">
<title>Using KCachegrind</title>

<para>
Note: Every widget in KCachegrind has "Whats' this" help.
If you don't want to search this documentation, use these!
</para>

<sect1>
<title>Quickstart Examples</title>


<para>Simple run it!</para>
</sect1>

<sect1>
<title>Features of KCachegrind</title>

<para>Supports: arbitrary events, function grouping</para>
</sect1>

<sect1>
<title>General Guidelines</title>

<para>Effective Profiling...</para>

</sect1>
<sect1>
<title>Tutorial</title>

<para>A profiling session on KCachegrind...</para>

</sect1>
</chapter>

<chapter id="commands">
<title>Command Reference</title>

<sect1 id="kapp-mainwindow">
<title>The main KCachegrind window</title>
<para></para>

<sect2>
<title>The File Menu</title>
<para>
<variablelist>
<varlistentry>
<term><menuchoice>
<shortcut>
<keycombo><keycap>Ctrl</keycap><keycap>n</keycap></keycombo>
</shortcut>
<guimenu>File</guimenu>
<guimenuitem>New</guimenuitem>
</menuchoice></term>
<listitem><para><action>Creates a new document</action></para></listitem>
</varlistentry>
<varlistentry>
<term><menuchoice>
<shortcut>
<keycombo><keycap>Ctrl</keycap><keycap>s</keycap></keycombo>
</shortcut>
<guimenu>File</guimenu>
<guimenuitem>Save</guimenuitem>
</menuchoice></term>
<listitem><para><action>Saves the document</action></para></listitem>
</varlistentry>
<varlistentry>
<term><menuchoice>
<shortcut>
<keycombo><keycap>Ctrl</keycap><keycap>q</keycap></keycombo>
</shortcut>
<guimenu>File</guimenu>
<guimenuitem>Quit</guimenuitem>
</menuchoice></term>
<listitem><para><action>Quits</action> &kapp;</para></listitem>
</varlistentry>
</variablelist>
</para>

</sect2>

</sect1>
</chapter>

<chapter id="faq">
<title>Questions and Answers</title>

&reporting.bugs;
&updating.documentation;

<qandaset id="faqlist">
<qandaentry>
<question>
<para>KCachegrind looks cool. But I don't understand it. 
What is it useful for?</para>
</question>
<answer>
<para>KCachegrind is a helpful at a later stage in software development,
called Profiling. If you don't develop applications, you don't need
KCachegrind.
</para>
</answer>
</qandaentry>
<qandaentry>
<question>
<para>I get compile errors, what could be the problem?</para>
</question>
<answer>
<para>Often, your QT installation hasn't KDE support....
</para>
</answer>
</qandaentry>
</qandaset>
</chapter>

<chapter id="credits">


<title>Credits and License</title>

<para>
&kapp;
</para>
<para>
Thanks to Julian Seward for its excellent Valgrind, and Nicholas Nethercote
for the Cachegrind addition. Without these programs, neither the
call tree patch for Valgrind nor KCachegrind would exist.
A lot of ideas for this GUI were from them, too.
</para>
<para>
And thanks for all the bug reports/suggestions from different
users. Last but not least, thanks to
<itemizedlist>
<listitem><para>KDE, the wonderful Application framework,</para>
</listitem>
<listitem><para>QT, the perfect GUI toolkit</para>
</listitem>
<listitem><para>Linux, the definitive OS</para>
</listitem>
</itemizedlist>
</para>

&underGPL;        	 <!-- GPL License -->

</chapter>

<appendix id="installation">
<title>Installation</title>

<sect1 id="getting-kcachegrind">
<title>How to obtain KCachegrind</title>

<para>
&kcachegrind; has its homepage at
<ulink url="http://www.weidendorfers.de/kcachegrind">
http://www.weidendorfers.de/kcachegrind</ulink>.
Look there for further installation and compile instructions.
</para>
</sect1>

<sect1 id="requirements">
<title>Requirements</title>

<para>
In order to successfully use &kcachegrind;, you need KDE 3.0.x.
For generating profile traces, Cachegrind is needed. To allow
for the most interesting visualization options of KCachegrind,
apply the call-tree patch from the KCachegrind homepage to your
Valgrind sources.
</para>
</sect1>

<sect1 id="compilation">
<title>Compilation and Installation</title>

<para>
In order to compile and install KCachegrind on your system, type the following in the base
directory of the source distribution:
<screen width="40">
<prompt>%</prompt> <userinput>./configure</userinput>
<prompt>%</prompt> <userinput>make</userinput>
<prompt>%</prompt> <userinput>make install</userinput>
</screen>
</para>

<para>Since KCachegrind uses autoconf and automake you should have not trouble compiling it.
Should you run into problems please report them to the KDE mailing lists.</para>

</sect1>

<sect1 id="configuration">
<title>Configuration</title>

<para>All configuration options are either in the configuration dialog
or in the context popup menues of the graphs.
</para>

</sect1>

</appendix>

&documentation.index;
</book>
<!--
Local Variables:
mode: sgml
sgml-minimize-attributes:nil
sgml-general-insert-case:lower
sgml-indent-step:0
sgml-indent-data:nil
End:
-->













