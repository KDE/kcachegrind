<?xml version="1.0" ?>
<!DOCTYPE book PUBLIC "-//KDE//DTD DocBook XML V4.5-Based Variant V1.1//EN" "dtd/kdedbx45.dtd" [
  <!ENTITY kcachegrind '<application
>KCachegrind</application
>'>
  <!ENTITY cachegrind "<application
>Cachegrind</application
>">
  <!ENTITY calltree "<application
>Calltree</application
>">
  <!ENTITY callgrind "<application
>Callgrind</application
>">
  <!ENTITY valgrind "<application
>Valgrind</application
>">
  <!ENTITY oprofile "<application
>OProfile</application
>">
  <!ENTITY EBS "<acronym
>EBS</acronym
>">
  <!ENTITY TBS "<acronym
>TBS</acronym
>">
  <!ENTITY % addindex "IGNORE">
  <!ENTITY % Ukrainian "INCLUDE">
]>

<book id="kcachegrind" lang="&language;">

<bookinfo>
<title
>Підручник з &kcachegrind;</title>

<authorgroup>
<author
><firstname
>Josef</firstname
> <surname
>Weidendorfer</surname
> <affiliation
> <address
><email
>Josef.Weidendorfer@gmx.de</email
></address>
</affiliation>
<contrib
>Перший автор документації</contrib>
</author>

<author
><firstname
>Federico</firstname
> <surname
>Zenith</surname
> <affiliation
> <address
><email
>federico.zenith@member.fsf.org</email
></address>
</affiliation>
<contrib
>Оновлення і виправлення</contrib>
</author>

<othercredit role="translator"
><firstname
>Юрій</firstname
><surname
>Чорноіван</surname
><affiliation
><address
><email
>yurchor@ukr.net</email
></address
></affiliation
><contrib
>Переклад українською</contrib
></othercredit
> 

</authorgroup>

<copyright>
<year
>2002-2004</year>
<holder
>&Josef.Weidendorfer;</holder
>	
</copyright>
<copyright>
<year
>2009</year>
<holder
>Federico Zenith</holder>
</copyright>
<legalnotice
>&FDLNotice;</legalnotice>

<date
>18 листопада 2016 року</date>
<releaseinfo
>0.8.0 (Програми 17.04)</releaseinfo>

<abstract>
<para
>&kcachegrind; — це інструмент для візуалізації даних профілювання, створений з використанням &kde-frameworks;. </para>
</abstract>

<keywordset>
<keyword
>KDE</keyword>
<keyword
>kdesdk</keyword>
<keyword
>Cachegrind</keyword>
<keyword
>Callgrind</keyword>
<keyword
>Valgrind</keyword>
<keyword
>Профілювання</keyword>
</keywordset>

</bookinfo>


<chapter id="introduction">
<title
>Вступ</title>

<para
>&kcachegrind; — програма, призначена для перегляду даних, створених інструментами для профілювання. У цій главі ми обговоримо призначення профілювання, способи його виконання, також наведемо приклади можливих інструментів профілювання. </para>

<sect1 id="introduction-profiling">
<title
>Профілювання</title>

<para
>Під час розробки програми одним з останніх кроків часто є оптимізація швидкодії. Оскільки оптимізація функцій, які використовуються рідко не має великого сенсу, потрібно знати кількість процесорного часу, яку споживає кожна з частин програми. </para>

<para
>Для послідовного коду збирання статистичних даних щодо характеристик запущеної програми, зокрема час, витраченого на виконання функцій і рядків, зазвичай, достатньо. Збирання таких даних називається профілюванням. Програма запускається під керуванням інструменту профілювання, це надає резюме щодо виконання наприкінці. Навпаки, для розпаралеленого коду проблеми з швидкодією може бути спричинено очікуванням одного процесора на передавання даних від іншого процесора. Оскільки цей час очікування, зазвичай, важко пов’язати з кодом, у такому випадку краще створити трасування подій з часовими позначками. &kcachegrind; не може створити візуальний відповідник цього типу даних. </para>

<para
>Після аналізу створених даних профілю ви маєте з легкістю виявити прогалини і вузькі місця у коді: наприклад, можна перевірити припущення щодо кількості викликів, виявлені діапазони коду може бути оптимізовано. Після цього ви можете перевірити результати оптимізації за допомогою повторного запуску профілювання. </para>
</sect1>

<sect1 id="introduction-methods">
<title
>Способи профілювання</title>

<para
>Щоб точно виміряти час на виконання або записати події, які сталися під час виконання певного діапазону коду (наприклад функції), слід вставити додатковий код для вимірювання перед і після вказаного діапазону. Цей код зчитує час або загальну кількість подій, а потім обчислює різниці. Отже, перед виконанням початкового коду його слід змінити. Така зміна називається інструменталізацією. Інструменталізацію може виконати сам програміст, компілятор або система запуску. Оскільки цікаві діапазони коду зазвичай є вкладеними, накладання інструментів вимірювання завжди впливає на самі виміри. Таким чином, інструменталізацію слід виконувати вибірково, а результати слід сприймати з певною поправкою. Звичайно ж, це робити аналіз швидкодії точним виміром дуже складним процесом.</para>

<para
>Точне вимірювання можливе, оскільки у сучасних процесорах передбачено апаратні лічильники (зокрема збільшення лічильників за один тік процесора), які збільшують значення кожного разу, коли трапляється подія. Оскільки нам потрібно пов’язати події з діапазонами коду, без лічильників нам би довелося обробляти кожну з подій шляхом збільшення значення лічильника для самого поточного діапазону коду. Виконання цього завдання у програмному забезпеченні, звичайно ж, неможливе; але, за припущення, що розподіл подій у вихідному коді є подібним до того, який ми отримуємо під час аналізу кожної n-ої події замість кожної події, можна створити метод вимірювання з контрольованим рівнем помилки: такий метод називається вибірковим контролем. Заснований на часі вибірковий контроль (Time Based Sampling або &TBS;) використовує таймер для регулярного стеження за лічильником програм для створення гістограми коду програми. Заснований на подіях вибірковий контроль (Event Based Sampling або &EBS;) використовує апаратні лічильники сучасних процесорів, а також режим, за якого лічильник подій зменшує значення шляхом виклику інструменту переривання на час створення гістограми відповідного розподілу подій: у інструменті переривання лічильник подій завжди переініціалізується на значення <symbol
>n</symbol
>-ого кроку вибіркового контролю. Перевагою вибіркового контролю є те, що код змінювати не потрібно, але цей спосіб все ж проміжним: використане під час обґрунтування методу припущення буде точнішим, якщо <symbol
>n</symbol
> достатньо мале, але, чим меншим буде <symbol
>n</symbol
>, тим вищою буде кількість додаткових викликів інструменту переривання.</para>

<para
>Ще одним методом вимірювання є імітація процесу, який відбувається у комп’ютерній системі під час виконання вказаного коду, тобто імітацією, заснованою на виконанні. Імітація завжди виконується на допомогою більшою чи меншою мірою точної моделі комп’ютера; але, якщо модель комп’ютера буде дуже детальною і даватиме дуже близькі до реальних дані, час імітації буде неприйнятно великим. Перевагою імітації є те, що ви можете додавати у вказаний код вимірювання/імітації довільної складності без впливу на результати. Виконання цього додавання перед виконанням (це називається інструменталізацію виконання) за допомогою початкового виконуваного файла є дуже зручним для користувача: не потрібне ніяке перезбирання. Імітація стає придатною для використання за імітації лише частин комп’ютера за допомогою простої моделі; іншою перевагою є те, що результати, створені за допомогою простих моделей часто простіше зрозуміти: часто проблеми, пов’язані зі справжнім апаратним забезпечення (обладнанням), є те, що у отриманих результатів буде включено ефекти, які є наслідком роботи різних частин комп’ютера.</para>
</sect1>

<sect1 id="introduction-tools">
<title
>Інструменти профілювання</title>

<para
>Найвідомішим є інструмент профілювання GCC, <application
>gprof</application
>: для його використання вам потрібно зібрати програму з параметром <option
>-pg</option
>; після запуску програми буде створено файл <filename
>gmon.out</filename
>, який можна перетворити у придатну для читання форму за допомогою команди <command
>gprof</command
>. Одним з недоліків є потреба у перезбиранні для підготовки виконуваного файла, який має бути зв’язаним з бібліотеками статично. Тут використано створену компілятором інструменталізацію, — за якої буде виміряно час переходу викликів між функціями і відповідну кількість викликів з використанням &TBS;, — таким чином буде отримано гістограму розподілу часу у коді. З використанням обох цих джерел інформації можна виконати евристичне обчислення включеного часу функцій, тобто часу на обробку функції разом з усіма функціями, які було викликано з цієї функції. </para>

<para
>Для точного вимірювання для подій, які сталися, існують бібліотеки з функціями, які можуть читати дані з апаратних лічильників швидкодії. Найвідомішим у цьому плані є латка PerfCtr для &Linux; та архітектурно незалежні бібліотеки PAPI і PCL. Крім того, як ми про це говорили раніше, для точних вимірів потрібна інструменталізація коду. Можна використовувати або самі бібліотеки або автоматичні системи інструменталізації на зразок ADAPTOR (для інструменталізації вихідних кодів на FORTRAN) або DynaProf (вставка коду за допомогою DynInst).</para>

<para
>&oprofile; — це загальносистемний інструмент для профілювання для &Linux;, у якому використано опитування. </para>

<para
>У багатьох аспектах зручним способом профілювання є використання &cachegrind; або &callgrind;, які є імітаторами, які використовують оболонку інструменталізації &valgrind;. Оскільки за такої схеми немає потреби у доступі до апаратних лічильників (який є ускладненим у сучасних дистрибутивах &Linux;), а виконувані файли, які профілюватимуться, залишаться незмінними, такий спосіб є непоганою альтернативою іншим інструментам профілювання. Наслідки недоліку імітації, — сповільнення, — можна зменшити імітацією лише цікавих частин програми або зменшенням кількості ітерацій під час циклу. Без інструменталізації вимірювання/імітації використання &valgrind; коефіцієнт уповільнення змінюватиметься у діапазоні від 3 до 5. Крім того, якщо вас цікавлять лише граф викликів і кількість викликів, імітатор кешу можна вимкнути. </para>

<para
>Імітація кешу є першим кроком у наближенні справжніх часів, оскільки у сучасних комп’ютерах виконання дуже чутливе до використання так званих <emphasis
>кешів</emphasis
> (маленьких і швидких буферів пришвидшує повторний доступ до тих самих комірок основної пам’яті). &cachegrind; виконує імітацію кешу перехопленням доступу до пам’яті. Серед створеного потоку даних буде кількість доступів до інструкцій/даних у пам’яті і промахів кешу першого/другого рівнів, і співвідносить їх з рядками вихідних кодів і функціях запущеної програми. Комбінуванням цих кількостей промахів з використанням латентностей промахів від типових процесорів можна дістати оцінку витраченого часу. </para>

<para
>&callgrind; є розширенням &cachegrind;, яке будує граф викликів програми на льоту, тобто граф, на якому буде показано спосіб, у який функції викликають одна одну, та кількість подій, які трапилися під час виконання функції. Крім того, дані профілю, які буде зібрано, може бути розподілено між потоками і контекстами ланцюжків викликів. Цей інструмент може надати дані профілювання на рівні інструкцій, що забезпечить коментування дизасембльованого коду. </para>
</sect1>

<sect1 id="introduction-visualization">
<title
>Візуалізація</title>

<para
>Типово, інструменти профілювання створюють значний об’єм даних. Бажання пересуватися вниз і вгору графом викликів, разом з швидким перемиканням режиму сортування функцій, і бачити різноманітні типи подій, викликає потребу у створенні програми з графічним інтерфейсом, призначеної для виконання цього завдання. </para>

<para
>&kcachegrind; є інструментом візуалізації даних профілювання, який створено саме з вказаною вище метою. Незважаючи на те, що програму було від початку створено для перегляду даних з &cachegrind; і &calltree;, у ній передбачено інструменти перетворення, які призначено для показу даних профілювання, створених іншими інструментами. У додатку цього підручника ви зможете знайти опис формату файлів &cachegrind;/&callgrind;. </para>

<para
>Окрім списку функцій, впорядкованого відповідно до вимірів включеної і виключної вартості, який за бажання можна згрупувати за файлами вихідних кодів, спільними бібліотеками або класами C++, у &kcachegrind; передбачено різноманітні режими візуалізації для вибраної функції, зокрема <itemizedlist>
<listitem
><para
>перегляд графу викликів, на якому буде показано частину графу викликів навколо вибраної функції,</para>
</listitem>
<listitem
><para
>перегляд деревоподібної карти, за допомогою якого можна переглянути взаємозв’язки вкладених викликів разом з виміром включеної вартості для пришвидшення візуального виявлення проблемних функцій,</para>
</listitem>
<listitem
><para
>перегляди вихідного коду і коментарів дизасемблера, за допомогою якого можна переглянути подробиці щодо пов’язаних з вартістю рядків вихідних кодів і інструкцій асемблера.</para>
</listitem>
</itemizedlist>

</para>
</sect1>
</chapter>

<chapter id="using-kcachegrind">
<title
>Користування &kcachegrind;</title>

<sect1 id="using-profile">
<title
>Створення даних для візуалізації</title>

<para
>Першим, у чому виникне потреба є створення даних щодо швидкодії шляхом вимірів характеристик виконання програми за допомогою інструменту профілювання. У самому &kcachegrind; не передбачено інструменту профілювання, але ця програма непогано пристосована для показу даних &callgrind; або, за допомогою інструменту перетворення, даних &oprofile;. Хоча предметом цього підручника не є документування профілювання за допомогою цих інструментів, у наступному розділі наведено короткі початкові настанови щодо роботи з ними. </para>

<sect2>
<title
>&callgrind;</title>

<para
>&callgrind; є частиною <ulink url="http://valgrind.org"
>&valgrind;</ulink
>. Зауважте, що раніше програма називалася &calltree;, але ця назва не відповідала призначенню програми. </para>

<para
>Найпоширенішим способом використання є додавання перед командою запуску програми рядка <userinput
><command
>valgrind</command
> <option
>--tool=callgrind</option
></userinput
>, наприклад <blockquote
><para
><userinput
><command
>valgrind</command
> <option
>--tool=callgrind</option
> <replaceable
>myprogram</replaceable
> <replaceable
>myargs</replaceable
> </userinput
></para
></blockquote
> Після переривання роботи програми буде створено файл <filename
>callgrind.out.<replaceable
>pid</replaceable
></filename
>, який можна завантажити у &kcachegrind;. </para>

<para
>Додатковою можливістю є створення дампів даних профілювання за виклику вказаної функції вашої програми. Наприклад, для того, щоб отримати дані профілювання для інструменту показу вебсторінки у &konqueror;, вам може знадобитися створення дампу даних під час вибору пункту меню <menuchoice
><guimenu
>Перегляд</guimenu
><guimenuitem
>Перезавантажити</guimenuitem
></menuchoice
>. Цей пункт відповідає виклику <methodname
>KonqMainWindow::slotReload</methodname
>. Віддайте команду <blockquote
><para
><userinput
><command
>valgrind</command
> <option
>tool=callgrind</option
> <option
>--dump-before=KonqMainWindow::slotReload</option
> <replaceable
>konqueror</replaceable
> </userinput
></para
></blockquote
> Буде створено декілька файлів з даними для профілювання з додатковим послідовним номером наприкінці назви файла. Крім того, буде створено файл без такого номера наприкінці назви (його назва завершуватиметься PID процесу); після завантаження цього файла до &kcachegrind;, буде завантажено і всі інші файли, — їх можна переглянути у <guilabel
>огляді частин</guilabel
> і списку <guilabel
>частин</guilabel
>. </para>

</sect2>

<sect2>
<title
>&oprofile;</title>

<para
>&oprofile; можна отримати з <ulink url="http://oprofile.sf.net"
>його домашньої сторінки</ulink
>. Виконайте настанови зі встановлення з вебсайта; але, перш ніж виконувати ці настанови пошукайте відповідний пакунок у вашому дистрибутиві (наприклад &SuSE;). </para>

<para
>Загальносистемне профілювання можна виконувати лише користувачеві root. Оскільки за такого профілювання можна спостерігати за всіма діями у системі, слід виконувати наступні дії від імені користувача root. Спочатку, налаштуйте процес профілювання за допомогою графічного інтерфейсу <command
>oprof_start</command
> або інструменту командного рядка <command
>opcontrol</command
>. За стандартних налаштувань буде використано режим таймера (&TBS;, див. вступ). Щоб розпочати вимірювання, виконайте команду <userinput
><command
>opcontrol</command
> <option
>-s</option
></userinput
>. Після цього запустіть програму, яка вас цікавить, і виконайте команду <userinput
><command
>opcontrol</command
> <option
>-d</option
></userinput
>. Ця команда запише всі результати вимірювання до файлів у теці <filename class="directory"
>/var/lib/oprofile/samples/</filename
>. Для того, щоб мати змогу візуалізувати дані у &kcachegrind;, виконайте таку команду у порожній теці: <blockquote
><para
><userinput
><command
>opreport</command
> <option
>-gdf</option
> | <command
>op2callgrind</command
></userinput
></para
></blockquote
> Ця команда призведе до створення багатьох файлів, по одному файлу на кожну з програм, які було запущено у системі. Кожен з цих файлів можна окремо завантажити до &kcachegrind;. </para>

</sect2>
</sect1>

<sect1 id="using-basics">
<title
>Основи інтерфейсу користувача</title>

<para
>Після запуску &kcachegrind; з аргументом у вигляді назви файла даних профілювання або після завантаження цього файла за допомогою пункту меню <menuchoice
><guimenu
>Файл</guimenu
> <guimenuitem
>Відкрити...</guimenuitem
> </menuchoice
> ви побачите панель навігації, на якій міститиметься список функцій, розташовану ліворуч, праворуч же буде показано основну частину з даними візуалізації обраної функції. Цю область візуалізації можна налаштувати довільним чином так, щоб у ній було показано декілька візуалізацій одночасно. </para>

<para
>Після першого запуску програми цю область буде поділено на верхню і нижню частини, у кожній з яких ви побачите декілька вкладок з панелями перегляду. Для пересування цими панелями скористайтеся контекстними меню вкладок. Ви також можете скоригувати розміри вкладок за допомогою панелей роздільників. Щоб пришвидшити перемикання між різними компонуваннями перегляду, скористайтеся пунктами меню <menuchoice
><shortcut
><keycombo action="simul"
>&Ctrl;<keycap
>→</keycap
> </keycombo
></shortcut
> <guimenu
>Перегляд</guimenu
><guisubmenu
>Розкладка</guisubmenu
> <guimenuitem
>Перейти до наступного</guimenuitem
></menuchoice
> і <menuchoice
><shortcut
><keycombo action="simul"
>&Ctrl;<keycap
>←</keycap
> </keycombo
></shortcut
> <guimenu
>Перегляд</guimenu
><guisubmenu
>Розкладка</guisubmenu
> <guimenuitem
>Перейти до попереднього</guimenuitem
></menuchoice
>. </para>

<para
>Для візуалізації є важливим вибір активного типу подій: для &callgrind; це є, наприклад, промахи кешу або оцінка циклічності; для &oprofile; це є «Таймер» у найпростішому випадку. Ви можете змінити тип події за допомогою спадного списку на панелі інструментів або у перегляді <guilabel
>типу подій</guilabel
>. Перший огляд характеристик запуску можна отримати, якщо ви оберете функцію <function
>main</function
> у списку, розташованому ліворуч. Погляньте на візуалізацію графу виклику; там ви зможете побачити виклики, які було здійснено у вашій програмі. Зауважте, що у перегляді графу викликів буде показано лише функції з високими значеннями кількості подій. Подвійне клацання на позначках функцій на графі, перегляд буде змінено так, щоб було показано функції викликані вибраною вами функцією. </para>

<para
>Щоб краще вивчити можливості графічного інтерфейсу програми на додачу до цього підручника, зазирніть до розділу документації на <ulink url="https://kcachegrind.github.io"
>вебсайті</ulink
>. Крім того, кожен з віджетів &kcachegrind; має довідку <quote
>Що це?</quote
>. </para>
</sect1>

</chapter>


<chapter id="kcachegrind-concepts">
<title
>Основні концепції</title>

<para
>У цій главі наведено пояснення деяких концепцій &kcachegrind; та наведено визначення термінів, що вживаються у інтерфейсі програми. </para>

<sect1 id="concepts-model">
<title
>Модель даних для даних профілювання</title>

<sect2>
<title
>Елементи вартості</title>

<para
>Лічильники вартості типів подій (на зразок промахів L2) пов’язано з елементами вартості, які є елементами відносно вихідних кодів або структур даних вказаної програми. Елементи вартості можуть бути не лише прості позиції у коді або даних, але і пари позицій. Наприклад, у виклику є джерело і призначення або адреса у даних може мати тип даних і позицію у коді, з якої було викликано її виділення. </para>

<para
>Елементи вартості, відомі &kcachegrind;, може бути подано у наведеному нижче вигляді. Прості позиції: <variablelist
><varlistentry
> <term
>Інструкція</term
> <listitem
><para
>Інструкція асемблера за заданою адресою. </para
></listitem
> </varlistentry
> <varlistentry
><term
>Рядок коду у функції</term
><listitem
><para
>Всі інструкції, які компілятор (за допомогою відомостей для усування вад) пов’язує з заданим рядком коду, який визначається за назвою файла і номером рядка і який виконується у контексті певної функції. Останній потрібен, оскільки рядок коду у вбудованій функції може з’являтися у контексті декількох функцій. Інструкції без жодних прив’язок до справжнього рядка коду пов’язуються з рядком з номером 0 у файлі <filename
>???</filename
>. </para
></listitem
></varlistentry
><varlistentry
><term
>Функція</term
> <listitem
><para
>Всі рядки коду певної функції самі складаються з функцій. Кожна функція задається своєю назвою і розташування у певному бінарному об’єкті, якщо він доступний. Останній потрібен, оскільки бінарні об’єкти окремої програми можуть міститися функції з однаковими назвами (до цих функцій можна отримати доступ, наприклад за допомогою <function
>dlopen</function
> або <function
>dlsym</function
>; інструмент прив’язки під час виконання визначає функції у вказаному порядку пошуку використаних бінарних об’єктів). Якщо інструмент профілювання не може визначити назву символу функції, наприклад, оскільки інформація для усування вад недоступна, буде типово використано або адресу першої виконаної інструкції, або <function
>???</function
>. </para
></listitem
></varlistentry
> <varlistentry
><term
>Бінарний об’єкт</term
> <listitem
><para
>Всі функції, чий код перебуває у діапазоні вказаного бінарного об’єкта, основного виконуваного файла або спільної бібліотеки.</para
></listitem
> </varlistentry
><varlistentry
><term
>Файл вихідних кодів</term
> <listitem
><para
>Всі функції, перша інструкція яких пов’язується з рядком певного файла вихідних кодів. </para
></listitem
></varlistentry
><varlistentry
><term
>Клас</term
> <listitem
><para
>Символічні назви функцій, типово, впорядковано за просторами назв, наприклад просторами назв C++ або класами у об’єктно-орієнтованих мовах; отже, клас може містити функції класу або самих вбудованих класів. </para
></listitem
> </varlistentry
><varlistentry
><term
>Частина профілювання</term
> <listitem
><para
>Певний часовий розділ запуску профілювання з певним ідентифікатором потоку, ідентифікатором процесу і рядком команди, яку слід виконати. </para
></listitem
> </varlistentry
></variablelist
> Як можна бачити зі списку, набір елементів вартості часто визначає інший елемент вартості; таким чином, існує послідовна ієрархія елементів вартості, структуру якої можна зрозуміти з наведеного вище опису. </para>

<para
>Пари позицій: <itemizedlist
> <listitem
><para
> Виклик з адреси інструкції до функції призначення. </para
></listitem
> <listitem
><para
> Виклик з рядка вихідних кодів до функції призначення. </para
></listitem
> <listitem
><para
> Виклик з функції вихідних кодів до функції призначення. </para
></listitem
> <listitem
><para
> (Без)умовний перехід з вихідних кодів до інструкції призначення. </para
></listitem
> <listitem
><para
> (Без)умовний перехід з вихідних кодів до рядка призначення. </para
></listitem
> </itemizedlist
> Переходи між функціями заборонено, оскільки такі переходи не мають сенсу у графі викликів; таким чином, конструкції на зразок обробки виключень і довгих переходів у C слід перетворити, за потреби, на виштовхування стеку викликів. </para>

</sect2>


<sect2>
<title
>Типи подій</title>

<para
>Довільні типи подій може бути визначено у даних профілювання наданням їм назви. Їх вартість відносно елемента вартості є 64-розрядним цілим числом. </para>
<para
>Типи подій, чию вартість вказано у файлі даних профілювання, називаються справжніми подіями. Крім того, ви можете вказати формули для типів подій, обчислені на основі справжніх подій, які називаються успадкованими подіями. </para>
</sect2>

</sect1>

<sect1 id="concepts-state">
<title
>Стан візуалізації</title>

<para
>Стан візуалізації вікна &kcachegrind; включає: <itemizedlist
> <listitem
><para
> основні і вторинні типи подій, обраних для показу, </para
></listitem
> <listitem
><para
> групування функцій (використовується у списку <guilabel
>Функції профілювання</guilabel
> і розфарбування елементів), </para
></listitem
> <listitem
><para
> частини профілювання, чиї вартості слід включити до візуалізації, </para
></listitem
> <listitem
><para
> активний елемент вартості (наприклад вибраної на панелі функцій функції), </para
></listitem
> <listitem
><para
> вибраний елемент вартості. </para
></listitem
> </itemizedlist
> Цей стан впливає на візуалізацію. </para>

<para
>Вміст панелі перегляду завжди відповідатиме одному, активному, елементу вартості. Якщо певна панель не відповідає елементу вартості, її буде вимкнено (наприклад, якщо вибрати об’єкт &ELF; у списку групи, коментарі у вихідних кодах не матимуть сенсу). </para>

<para
>Наприклад, для активної функції, у списку викликаних буде показано всі функції, які було викликано з активної функції: ви можете обрати одну з цих функцій, не роблячи її активною; крім того, якщо граф викликів показано поруч, у ньому також буде вибрано відповідну функцію. </para>

</sect1>

<sect1 id="concepts-guiparts">
<title
>Частини графічного інтерфейсу користувача</title>

<sect2>
<title
>Бічні панелі</title>
<para
>Бічні панелі є бічними вікнами, які можна розташовувати поряд з будь-якою з меж вікна &kcachegrind;. На них завжди міститься список елементів вартості, впорядкованих у той же спосіб. <itemizedlist>
<listitem
><para
><guilabel
>Профіль функцій</guilabel
> є списком, у якому буде показано включену і виключну вартість, кількість викликів, назву і позицію функцій. </para
></listitem>
<listitem
><para>
<guilabel
>Огляд частин</guilabel>
</para
></listitem>
<listitem
><para>
<guilabel
>Стек викликів</guilabel>
</para
></listitem>
</itemizedlist>
</para>
</sect2>

<sect2>
<title
>Область перегляду</title>
<para
>Область перегляду, яка типово розташована у правій частині головного вікна &kcachegrind;, складається з одної (типової) або декількох вкладок, вирівняних горизонтально або вертикально. У кожному з переглядів вкладки містяться різноманітні дані для одного окремого елемента вартості. Назву цього елемента буде показано у верхній частині вкладки. Якщо відкрито декілька вкладок, лише одна з них буде активною. Назву елемента у активному перегляді вкладок буде показано жирним шрифтом, вона визначає активний елемент вартості вікна &kcachegrind;. </para>
</sect2>

<sect2>
<title
>Області у вкладках</title>
<para
>На кожній з вкладок може міститися до чотирьох областей перегляду, а саме верхня, права, ліва і нижня. У кожній з областей можуть міститися декілька переглядів візуалізації у вигляді стосу. Видиму частину області можна обрати за допомогою панелі вкладок. Панелі вкладок верхньої і правої областей знаходяться вгорі; панелі вкладок лівої і нижньої областей знаходяться внизу. Ви можете визначати різновид перегляду для кожної з областей за допомогою контекстних меню вкладок. </para>
</sect2>

<sect2>
<title
>Синхронізований перегляд з вибором елемента у вкладці</title>
<para
>Окрім активного елемента, у кожній вкладці є вибраний елемент. Оскільки у більшості з типів перегляду буде показано декілька елементів, активний елемент буде певним чином розташовано по центру, ви можете змінити вибраний елемент навігацією на панелі перегляду (клацанням кнопкою миші або за допомогою клавіатури). Типово, вибрані елементи буде підсвічено. Зміною вибраного елемента у одній з областей перегляду з вкладками, на всіх інших панелях у перегляді з вкладками буде відповідно підсвічено новий вибраний елемент. </para>
</sect2>

<sect2>
<title
>Синхронізація між вкладками</title>
<para
>Якщо буде відкрито декілька вкладок, зміна вибраного елемента на одній з вкладок призведе до зміни активації у наступному (праворуч/внизу) перегляді з вкладками. Цей тип прив’язки, наприклад, забезпечує швидку навігацію графами викликів. </para>
</sect2>

<sect2>
<title
>Компонування</title>
<para
>Компонування всіх переглядів з вкладками можна зберегти (за допомогою пункту меню <menuchoice
><guimenu
>Перегляд</guimenu
><guisubmenu
>Розкладка</guisubmenu
></menuchoice
>). Після дублювання поточного компонування (<menuchoice
><shortcut
><keycombo action="simul"
>&Ctrl; <keycap
>+</keycap
></keycombo
></shortcut
> <guimenu
>Перегляд</guimenu
> <guisubmenu
>Розкладка</guisubmenu
><guimenuitem
>Здублювати</guimenuitem
> </menuchoice
>) і зміни певних розмірів або пересування перегляду до іншої області перегляду з вкладками, ви можете швидко перемикатися між старим і новим компонуванням за допомогою комбінацій клавіш <keycombo action="simul"
> &Ctrl;<keycap
>←</keycap
></keycombo
> і <keycombo action="simul"
>&Ctrl; <keycap
>→</keycap
></keycombo
>. Набір компонувань буде збережено між сеансами роботи з &kcachegrind; над тією самою командою профілювання. Ви може зробити поточний набір компонувань як типовий для нових сеансів &kcachegrind; або відновити типовий набір компонувань. </para>
</sect2>
</sect1>

<sect1 id="concepts-sidedocks">
<title
>Бічні панелі</title>

<sect2>
<title
>Плоский профіль</title>
<para
><guilabel
>Плоский профіль</guilabel
> містить список груп і список функцій. У списку груп міститься перелік всіх груп, на які витрачаються ресурси системи, залежно від обраного типу груп. Список груп буде приховано, якщо групування буде вимкнено. </para>
<para
>У списку функцій міститься перелік функцій вибраної групи (або всіх функцій, якщо групування вимкнено), впорядкованих за певним стовпчиком, наприклад включених або власних вартостей. Існує обмеження на максимальну кількість функцій, показаних у списку, його можна налаштувати за допомогою вікна, яке відкривається пунктом меню <menuchoice
><guimenu
>Параметри</guimenu
> <guimenuitem
>Налаштувати &kcachegrind;</guimenuitem
></menuchoice
>. </para>
</sect2>

<sect2>
<title
>Огляд частин</title>
<para
>Під час виконання профілювання може бути створено декілька файлів даних профілювання, їх можна завантажити разом у &kcachegrind;. Ці файли буде показано на панелі <guilabel
>Огляд частин</guilabel
>, файли буде впорядковано у відповідності до часу створення; розміри прямокутників будуть пропорційними до вартості відповідних частин. Ви можете обрати одну або декілька частин, щоб обмежити перелік вартостей, які буде показано у інших переглядах &kcachegrind;, лише цими частинами. </para>
<para
>Частини поділяються на менші частини. Існує режим розбиття і розділення включеної вартості: <variablelist>
<varlistentry>
<term
><guilabel
>Режим розбиття</guilabel
></term>
<listitem
><para
>Ви побачите розбиття на групи для частини даних профілювання, відповідно до обраного типу груп. Наприклад, якщо обрано групи об’єктів &ELF;, ви побачите розфарбовані прямокутники для кожного використаного об’єкта &ELF; (спільної бібліотеки або виконуваного файла), їх розмір буде пропорційним до вартості використання ресурсів системи. </para
></listitem>
</varlistentry>
<varlistentry>
<term
><guilabel
>Режим діаграм</guilabel
></term>
<listitem
><para
>Буде показано прямокутник, що відповідає включеній вартості поточної активної функції у частині. Цей перегляд, знову, буде розділено для того, щоб показати включені вартості викликаних елементів. </para
></listitem>
</varlistentry>
</variablelist>
</para>
</sect2>

<sect2>
<title
>Стек викликів</title>
<para
>Це цілком уявний «найбільш ймовірний» стек викликів. Його буде побудовано починаючи з поточної активної функції, туди буде додано виклики і викликані елементи з найвищою вартістю у верхню і нижню частину списку. </para>
<para
>У стовпчиках <guilabel
>Вартість</guilabel
> і <guilabel
>Виклики</guilabel
> буде показано вартість, використану для всіх викликів з функції у рядку, розташованому вище. </para>
</sect2>
</sect1>

<sect1 id="concepts-views">
<title
>Перегляди</title>

<sect2>
<title
>Тип події</title>
<para
>У списку <guilabel
>Тип подій</guilabel
> буде показано всі доступні типи вартості і відповідну власну і включену вартості поточної активної функції для відповідного типу події. </para>
<para
>Вибором певного типу подій зі списку ви можете змінити тип вартостей, який буде показано у всіх інших переглядах &kcachegrind;, які буде обрано. </para>
</sect2>

<sect2>
<title
>Списки викликів</title>
<para
>Тут буде показано список викликів до/з поточної активної функції. За допомогою панелей <guilabel
>Всі виклики</guilabel
> і <guilabel
>Всі викликані функції</guilabel
> можна переглянути всі функції, яких можна досягти вздовж ланцюжка виклики/викликані, навіть якщо існують інші проміжні функції. </para>

<para
>У переглядах списку викликів містяться: <itemizedlist>
<listitem
><para
>Безпосередні зовнішні виклики</para
></listitem>
<listitem
><para
>Безпосередні внутрішні виклики</para
></listitem>
<listitem
><para
><guilabel
>Всі зовнішні виклики</guilabel
></para
></listitem>
<listitem
><para
><guilabel
>Всі внутрішні виклики</guilabel
></para
></listitem>
</itemizedlist>
</para>
</sect2>

<sect2>
<title
>Карти</title>
<para
>Перегляд деревоподібної карти основного типу подій, вгору або вниз ієрархією викликів. Кожному розфарбованому прямокутнику відповідає функція, розмір прямокутника приблизно пропорційний до вартості у ресурсах системи виконання активної функції (крім того, існують певні обмеження малювання). </para>
<para
>У разі показу <guilabel
>Карта викликів</guilabel
> на графі буде показано ієрархію всіх функцій, що викликали поточну активовану функцію. У разі показу <guilabel
>Карти викликаних</guilabel
> буде показано ієрархію всіх функцій викликаних активованою функцією. </para>
<para
>Параметри вигляду можна знайти у контекстному меню. Щоб отримати точні пропорції, позначте пункт <guimenuitem
>Пропустити некоректні границі</guimenuitem
>. Оскільки побудова графів у подібному режимі є досить тривалою, ймовірно, вам слід обмежити максимальний рівень вкладеності до початку побудови. За вибору <guilabel
>Найкращого</guilabel
> режиму напрямок поділу для дочірніх елементів буде визначено зі співвідношення сторін батьківського елемента. За вибору режиму <guilabel
>Завжди найкращий</guilabel
> вибір відбуватиметься на основі доступного простору для елементів одного рівня. У режимі <guilabel
>Ігнорувати пропорції</guilabel
> прості для показу назви функції буде забрано перед малюванням дочірніх елементів. Зауважте, що пропорції за розмірами можуть бути дуже неточними. </para>
<para
>Ви можете скористатися клавішами зі стрілками ліворуч/праворуч для пересування між елементами одного рівня, клавіші зі стрілочками вгору/вниз можна використати для пересування між рівнями вкладеності. Клавіша &Enter; активує поточний елемент. </para>
</sect2>

<sect2>
<title
>Граф викликів</title>
<para
>У цьому перегляді буде показано граф викликів навколо активної функції. Показана вартість є лише вартістю, яку було витрачено під час виконання самої активної функції; тобто вартість, показану для функції <function
>main()</function
>, — якщо вона є видимою, — має бути тією самою, що і вартість активної функції, оскільки вона є частиною включеної вартості <function
>main()</function
>, витраченої під час виконання активної функції. </para>
<para
>Для циклів сині стрілки викликів позначатимуть, що ви маєте справу з штучним викликом, доданим для правильного показу, цей виклик ніколи не виконується. </para>
<para
>Якщо розмір графу перевищує площу віджета, у одному з кутів буде показано елемент загального перегляду. Існують подібні до карти викликів параметри візуалізації, вибрану функцію буде підсвічено. </para>
</sect2>

<sect2>
<title
>Примітки</title>
<para
>У коментованих списках вихідних кодів/кодів асемблера буде показано рядки вихідних кодів/дизасембльовані інструкції поточної активної функції, а також (власну) вартість на виконання коду рядка вихідних кодів/інструкції. Якщо це був виклик, у вихідні коди буде вставлено рядки з подробицями щодо виклику: (включену) вартість виклику, кількість виконаних викликів і призначення викликів. </para>
<para
>Оберіть певний рядок відомостей про виклики, щоб активувати призначення виклику. </para>
</sect2>
</sect1>

</chapter>


<chapter id="commands">
<title
>Довідка щодо команд</title>

<sect1 id="kcachegrind-mainwindow">
<title
>Головне вікно &kcachegrind;</title>

<sect2>
<title
>Меню «Файл»</title>
<para>
<variablelist>

<varlistentry>
<term
><menuchoice
><shortcut
> <keycombo
>&Ctrl;<keycap
>N</keycap
></keycombo
> </shortcut
> <guimenu
>Файл</guimenu
> <guimenuitem
>Створити</guimenuitem
> </menuchoice
></term>
<listitem
><para
><action
>Відкрити порожнє вікно верхнього рівня</action
>, у яке ви можете завантажите дані профілювання. Насправді, цей пункт не дуже то і потрібен, оскільки за допомогою пункту меню <menuchoice
><guimenu
>Файл</guimenu
> <guimenuitem
>Відкрити...</guimenuitem
> </menuchoice
> ви зможете відкрити нове вікно верхнього рівня, якщо у поточному вікні вже показано певні дані. </para
></listitem>
</varlistentry>

<varlistentry>
<term
><menuchoice
><shortcut
> <keycombo
>&Ctrl;<keycap
>O</keycap
></keycombo
> </shortcut
> <guimenu
>Файл</guimenu
> <guimenuitem
>Відкрити</guimenuitem
> </menuchoice
></term>
<listitem>
<para
><action
>Відкрити діалогове вікно відкриття файла &kde;</action
>, у якому ви зможете обрати файл даних профілювання, який слід завантажити. Якщо у поточному вікні верхнього рівня вже показано певні дані, програма відкриє нове вікно; якщо ви бажаєте додати дані профілювання у поточне вікно, скористайтеся пунктом меню <menuchoice
><guimenu
>Файл</guimenu
> <guimenuitem
>Додати...</guimenuitem
> </menuchoice
>. </para>
<para
>Назви файлів даних профілювання зазвичай завершуються на <literal role="extension"
>.<replaceable
>pid</replaceable
>.<replaceable
>частина</replaceable
>-<replaceable
>ідентифікатор потоку</replaceable
></literal
>, де <replaceable
>частина</replaceable
> і <replaceable
>ідентифікатор потоку</replaceable
> є необов’язковими, а <replaceable
>pid</replaceable
> і <replaceable
>частина</replaceable
> використовуються для декількох файлів даних профілювання, що стосуються одного запуску програми. Якщо завантажити файл, назва якого завершується лише на <literal role="extension"
><replaceable
>pid</replaceable
></literal
>, буде завантажено не лише файли даних для цього запуску, але і файли з додатковими суфіксами. </para>
<informalexample
><para
>Якщо існують файли даних профілювання <filename
>cachegrind.out.123</filename
> і <filename
>cachegrind.out.123.1</filename
>, після завантаження першого з файлів другий файл буде завантажено автоматично. </para
></informalexample
></listitem>
</varlistentry>

<varlistentry>
<term
><menuchoice
><guimenu
>Файл</guimenu
> <guimenuitem
>Додати...</guimenuitem
> </menuchoice
></term>
<listitem
><para
><action
>Додати файл даних профілювання</action
> у поточне вікно. За допомогою цього пункту ви можете примусити програму до завантаження декількох файлів даних до одного вікна верхнього рівня, навіть якщо вони не належать до одного запуску програми відповідно до угоди щодо назв файлів даних профілювання. Цим можна, наприклад, скористатися для порівняльного аналізу. </para
></listitem>
</varlistentry>

<varlistentry>
<term
><menuchoice
><shortcut
> <keycap
>F5</keycap
> </shortcut
> <guimenu
>Файл</guimenu
> <guimenuitem
>Перезавантажити</guimenuitem
> </menuchoice
></term>
<listitem
><para
><action
>Перезавантажити дані профілювання.</action
> Таке перезавантаження найцікавіше після того, як було створено інший файл даних профілювання для вже завантаженого запуску програми. </para
></listitem>
</varlistentry>

<varlistentry>
<term
><menuchoice
><shortcut
> <keycombo action="simul"
>&Ctrl;<keycap
>Q</keycap
></keycombo
> </shortcut
> <guimenu
>Файл</guimenu
> <guimenuitem
>Вийти</guimenuitem
> </menuchoice
></term>
<listitem
><para
><action
>Завершує роботу</action
> &kcachegrind;</para
></listitem>
</varlistentry>
</variablelist>
</para>

</sect2>

</sect1>
</chapter>

<chapter id="faq">
<title
>Запитання і відповіді</title>

<qandaset id="faqlist">


<qandaentry>
<question>
<para
>Для чого призначено &kcachegrind;? Не можу здогадатися. </para>
</question>
<answer>
<para
>&kcachegrind; корисний на останніх стадіях розробки програмного забезпечення, які називаються профілюванням. Якщо ви не є розробником програм, вам не потрібен &kcachegrind;. </para>
</answer>
</qandaentry>

<qandaentry>
<question>
<para
>У чому різниця між «Вкл.» і «Власна»? </para>
</question>
<answer>
<para
>Це атрибути вартості для функцій, що стосуються подій певного типу. Оскільки функції можуть викликати одна одну, має сенс відрізняти вартість самої функції («власну вартість») і вартість разом з всіма викликаними функціями («включену вартість»). «Власну» вартість іноді також називають «виключною». </para>
<para
>Отже, наприклад, для <function
>main()</function
> ви завжди матимете включену вартість близьку до 100%, тоді як власна вартість цієї функції є незначною, оскільки справжню роботу виконує інша функція. </para>
</answer>
</qandaentry>

<qandaentry>
<question>
<para
>Якщо навести вказівник на позначку функції у перегляді <guilabel
>графу викликів</guilabel
> і двічі клацнути лівою кнопкою миші, для функції <function
>main()</function
> буде показано ту саму вартість вибраної функції. Хіба вартість всіх функцій рівна сталій 100% ? </para>
</question>
<answer>
<para
>Якщо ви активуєте вкладену функцію <function
>main()</function
> її вартість буде меншою за вартість <function
>main()</function
>. Для будь-якої функції, буде показано лише частину повної вартості функції, цю вартість було витрачено на виконання <emphasis
>активованої</emphasis
> функції; тобто, вартість, показана для будь-якої функції ніколи не може перевищувати вартість активованої функції. </para>
</answer>
</qandaentry>


</qandaset>
</chapter>


<glossary>

<glossentry id="costentity">
<glossterm
>Елемент вартості</glossterm>
<glossdef
><para
>Абстрактний елемент, пов’язаний з вихідними кодами, з якими можна пов’язати кількість подій. Вимірами для елементів вартості є адреси коду (наприклад рядок вихідних кодів, функція), адреси даних (наприклад тип даних для доступу, об’єкт даних), адреса виконання (наприклад потік, процес) і пари або трійки вище наведених позицій (наприклад виклики, доступ до даних з інструкції, витискання даних з кешу).</para
></glossdef>
</glossentry>

<glossentry id="eventcosts">
<glossterm
>Вартість подій</glossterm>
<glossdef
><para
>Сума вартостей подій певного типу, які трапляються під час виконання, пов’язаного з певним елементом вартості. Вартість буде прив’язано до елемента.</para
></glossdef>
</glossentry>

<glossentry id="eventtype">
<glossterm
>Тип події</glossterm>
<glossdef
><para
>Різновид події, з яким можна пов’язати елемент вартості. Існують справжні типи подій і успадковані типи подій.</para
></glossdef>
</glossentry>

<glossentry id="inheritedeventtype">
<glossterm
>Успадкований тип подій</glossterm>
<glossdef
><para
>Віртуальний тип подій, видимий лише на панелях перегляду, визначений формулою, за якою можна обчислювати дані на основі справжніх типів подій.</para
></glossdef>
</glossentry>

<glossentry id="profiledatafile">
<glossterm
>Файл даних профілювання</glossterm>
<glossdef
><para
>Файл, у якому містяться дані, отримані під час випробування з профілюванням (або його частини), або дані, отримані на основі обробки траси. Зазвичай, розмір цього файла пропорційний розмірів коду програми.</para
></glossdef>
</glossentry>

<glossentry id="profiledatapart">
<glossterm
>Частина «Дані профілювання»</glossterm>
<glossdef
><para
>Дані з файла даних профілювання.</para
></glossdef>
</glossentry>

<glossentry id="profileexperiment">
<glossterm
>Експеримент з профілювання</glossterm>
<glossdef
><para
>Програму буде запущено під наглядом інструменту профілювання, що призведе до можливого створення декількох файлів профілювання запущених частин або потоків.</para
></glossdef>
</glossentry>

<glossentry id="profileproject">
<glossterm
>Проєкт з профілювання</glossterm>
<glossdef
><para
>Налаштування для експериментів з профілювання, які використовуватимуться для одної з профільованих програм, можливо, у декількох версіях. Порівняння даних профілювання, типово, має сенс лише між даними профілювання, створеними під час експериментів одного проєкту профілювання.</para
></glossdef>
</glossentry>

<glossentry id="profiling">
<glossterm
>Профілювання</glossterm>
<glossdef
><para
>Процес збирання статистичних відомостей щодо характеристик виконання запущеної програми.</para
></glossdef>
</glossentry>

<glossentry id="realeventtype">
<glossterm
>Справжній тип подій</glossterm>
<glossdef
><para
>Тип подій, які можна виміряти інструментом. Для вказаного типу подій потрібне існування сенсора.</para
></glossdef>
</glossentry>

<glossentry id="trace">
<glossterm
>Траса</glossterm>
<glossdef
><para
>Послідовність подій з позначками часу, які сталися під час трасування запущеної програми. Зазвичай, розмір траси пропорційний до часу виконання запущеної програми.</para
></glossdef>
</glossentry>

<glossentry id="tracepart">
<glossterm
>Частина «Трасування»</glossterm>
<glosssee otherterm="profiledatapart"/>
</glossentry>

<glossentry id="tracing">
<glossterm
>Трасування</glossterm>
<glossdef
><para
>Процес нагляду за виконанням програми зі збереженням списку подій програми, впорядкованого за часом у файлі виводу, трасі (Trace).</para
></glossdef>
</glossentry>

</glossary>

<chapter id="credits">

<title
>Подяки і ліцензія</title>

<para
>Дякуємо Julian Seward за його чудовий інструмент &valgrind;, а також Nicholas Nethercote за додавання &cachegrind;. Без цих програм &kcachegrind; ніколи не було б створено. Певні ідеї цього графічного інтерфейсу користувача також було запозичено з цих програм. </para>
<para
>Крім того, спасибі на повідомлення про вади та пропозиції іншим користувачам. </para>

<para
>Переклад українською: Юрій Чорноіван <email
>yurchor@ukr.net</email
></para
> &underFDL; </chapter>

&documentation.index;
</book>
